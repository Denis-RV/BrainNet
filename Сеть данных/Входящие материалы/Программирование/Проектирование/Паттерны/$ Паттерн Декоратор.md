# Паттерн Декоратор
*alternative names:* Wrapper, Decorator, Обертка.
*теги:* #python #java #проектирование 
*type:* #проектирование/паттерн/структурный
*описание:* Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные "обертки". Вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

---
### Проблема
Сторонние программы используют главный класс оповещений:
![[Pasted image 20210203172406.png]]
В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые изпользователей хотели бы получать извещения о критических проблемах через SMS. Другие пользователи хотят получать их в виде сообщений Facebook.

Сначала вы добавили каждый из этих видов оповещений в
программу, унаследовав их от базового класса
Notificator: ![[Pasted image 20210203173315.png]] Но возникла необходимость получать опвоещения сразу в нескольких программах. 

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того, как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.
![[Pasted image 20210203173516.png]] Нужен какой-то другой способ комбинировать
поведения объектов, который не приводит к взрыву
количества подклассов.

### Решение
Вы могли бы воспользоваться наследованием, но возникнет две проблемы: 1) Механизм наследования статичен, то есть не позволяет изменить поведение существующего объекта. 2) Механизм наследования не разрешает наследовать поведение нескольких классов одновременно. 

Паттерн Decorator предлагает обойти эти проблемы с помощью *композиции* ([[Java Base#Композиция]])

***Суть паттерна:*** вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Расширенные способы оповещения становятся декораторами: ![[Pasted image 20210203175133.png]]

Таким образом программа сможет составлять составные обхекты из декораторов: ![[Pasted image 20210203180701.png]]


### Структура решения
1. Компонент задаёт общий интерфейс обёрток и оборачиваемых объектов.
2. Конкретный Компонент определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.
3. Базовый Декоратор хранит ссылку на вложенный объект- компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
4. Конкретные Декораторы — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.
5. Клиент может оборачивать простые компоненты и декораторы в другие декораторы, старясь работать со всему объектами через общий интерфейс компонентов.

	![[Pasted image 20210203180723.png]]
	
### Псевдокод


### Применимость


### Шаги реализации


### Преимущества и недостатки
==Преимущества==:
- Большая гибкость, чем у наследников
- Позволяет добавлять обязанности на лету
- Можно добавлять несколько новых обязанностей сразу
- Позволяет иметь несколько мелких обхектов вместо одного обхекта на все случае жизни

==Недостатки==:
- Трудно конфигурировать многократно обернутые объекты
- Обилие крошечных классов

### Отношения с другими паттернами 
- [[$- Паттерн Адаптер]] меняет интерфейс существующего объекта. Декоратор улучшает другой обхект без изменения его интерфейса. Причем Декоратор поддерживает рекурсивную вложенность, в отличие ото Адаптера.
- [[$- Паттерн Адаптер]] предоставляет классу альтернативный интерфейс. Декоратор предоставляет расширенный интерфейс. [[$- Паттерн Proxy]] предоставляет тот же интерфейс.
- [[$- Паттерн Chain of Responsibility]] и декоратор имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Отличия: 
	- Обработчики в Chain of Responsibility могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерпывать дальнейшую передачу по цепочке. 
	- Декораторы расширяют какое-то определенное действие, не ломая интерфейс базовой операции и не прерывая выполнения остальных декораторов.
- [[$- Паттерн Composite]] и Декоратор имеют похожие структуры класссов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов. 

	Декоратор оборачивает только один объект, а узел Компоновщика может иметь много детей. Декоратор добавляет вложенному объекту новую функциоанальность, а Компоновщик не добавляет ничего нового, но "суммирует" результаты всех своих детей. 
	
	Они могут использоваться одновременно: Компоновщик может использовать Декоратор, чтобы переопределить функции отдельных частей дерева компонентов.
	
- Архитектура, псотроенная на [[$- Паттерн Composite]] и Декораторах, часто может быть улучшена за счет внедрения [[$- Паттерн Prototype]]. Он позволяет клонировать сложные структуры объетов, а не собирать их заново.
- [[$- Паттерн Strategy]] меняет поведение объекта "изнутри", а Декоратор изменяет его "снаружи"/
- Декоратор и [[$- Паттерн Proxy]] имеют похожие структуры, но разные назначения. Они похожи тем, что оба построены на композиции и делегировании работы другому объекту. Паттерны отличаются тем, что Заместитель сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.