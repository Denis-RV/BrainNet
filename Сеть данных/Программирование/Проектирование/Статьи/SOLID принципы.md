# SOLID принципы
*format:* stage
*теги:* #spring #java #python #design 
*описание:* Главная цель этих принципов — повысить гибкость вашей архитектуры, уменьшить связанность между её компонентами и облегчить повторное использование кода. Но, как и всё в этой жизни, соблюдение этих принципов имеет свою цену. Здесь это в основном выражается в усложнении кода программы.

---
## *S*ingle Responsibility Principle (Принцип единой ответственности)
>У класса должен быть только один мотив для изменения.

Стремитесь к тому, чтобы каждый класс отвечал только за одну часть функциональности программы, причём она
должна быть полностью инкапсулирована в этот класс

Когда класс разрастается, он просто перестаёт помещаться в голове. Навигация затрудняется, на глаза попадаются ненужные детали, связанные с другим аспектом, в результате, количество понятий начинают превышать мозговой стек, и вы начинаете терять контроль над кодом.

#### Пример:
Класс Employee имеет сразу несколько причин для изменения. Первая связана с основной задачей класса — это управлением данными сотрудника. Но есть и вторая: изменения, связанные с форматированием отчёта для
печати, будут затрагивать класс сотрудников.
![[Pasted image 20210201143056.png]]

Проблему можно решить, выделив операцию печати в отдельный класс.
![[Pasted image 20210201143114.png]]

## *O*pen/closed Principle (Принцип открытости/закрытости)
> Расширяйте классы, но не изменяйте их первоначальный вид.

Стремитесь к тому, чтобы классы были открыты для расширения, но закрыты для изменения. Главная идея этого принципа в том, чтобы не ломать существующий код при внесении изменений в программу.

#### Пример
- ДО: код класса заказа нужно будет изменять при добавлении нового способа доставки. ![[Pasted image 20210201162239.png]]

Проблема решается с помощью [[$- Паттерн Strategy]]. Для этого нужно выделить способы доставки в собственные классы с общим интерфейсом.
- ПОСЛЕ: новые способы доставки можно добавить, не трогая класс заказов. ![[Pasted image 20210201162410.png]]о

## *L*iskov Substitution Principle (Принцип подстановки Лисков)
> Подклассы должны дополнять, а не замещать поведение базового класса.

Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода.

==Принцип подстановки== — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом программы, который до этого успешно работал, используя объекты базового класса. Принцип подстановки имеет ряд формальных требований к подклассам, а точнее к переопределённым в них методах:
- Типы параметров метода подкласса должны совпадать или быть более абстрактными, чем типы параметров базового метода.
- Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода. 
- Метод не должен выбрасывать исключения, которые не свойственны базовому методу. Неожиданное исключение, выброшенное подклассом, может проскочить сквозь обработчики клиентского кода и обрушить программу.
- Метод не должен ужесточать предусловия. Например, базовый метод работает с параметром типа int . Если подкласс требует, чтобы значение этого параметра к тому же было больше нуля, то это ужесточает предусловия. Клиентский код, который до этого отлично работал, подавая в метод негативные числа, теперь сломается при работе с объектом подкласса.
- Метод не должен ослаблять постусловия.  Например, базовый метод требует, чтобы по завершению метода все подключения к базе данных были бы закрыты, а подкласс оставляет эти подключения открытыми, чтобы потом повторно использовать. Но клиентский код базового класса ничего об этом не знает. Он может завершить программу сразу после вызова метода, оставив запущенные процессы - призраки в системе.
- Инварианты класса должны остаться без изменений. ==Инвариант== — это набор условий, при которых объект имеет смысл. Например, инвариант кота — это наличие четырёх лап, хвоста, способность мурчать и прочее. Инвариант может быть описан не только явным контрактом или проверками в методах класса, но и косвенно, например, юнит-тестами или клиентским кодом.

## *I*nterface Segregation Principle
>Клиенты не должны зависеть от методов, которые они не используют.

Стремитесь к тому, чтобы интерфейсы были достаточно узкими, чтобы классам не приходилось реализовывать избыточное поведение.

Слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.

## *D*ependency Inversion Principle
> Классы верхних уровней не должны зависеть от классов нижних уровней. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

**При проектировании программ выделяется два уровня классов:**
- *Классы нижнего уровня* реализуют базовые операции вроде работы с диском, передачи данных по сети, подключению к базе данных и прочее.
- *Классы высокого уровня* содержат сложную бизнес-логику программы, которая опирается на классы низкого уровня для осуществления более простых операций.

Обычно классы нижнего уровня проектируют раньше, и классы бизнес-логики становятся зависимыми от более примитивных низкоуровневых классов. Изменения в низкоуровневых классах затрагивают классы бизнес-логики.

Принцип инверсии зависимостей предлагает изменить направление, в котором происходит проектирование:
1. В начале нужно описать интерфейс низкоуровневых операций, которые нужны классу бизнес-логики
2. Это позволяет убрать зависимость класса бизнес-логики от конкретного низкоуровнего класса, заменив ее мягкой зависимостью от интерфейса.
3. Низкоуровневый класс, в свою очередь станет зависимым от интерфейса определенного бизнес-логикой.