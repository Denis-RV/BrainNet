# Взгляд на мир глазами командной оболочки
*Need to know:* [[1.4 Перенаправление ввода и вывода]]
*tags:* #linux #editText 

---

## Подстановка
Когда мы нажимаем ENTER, bash выполняет несколько операций с текстом, прежде чем выполнит вашу команду. Когда вы используете \*, происходит подстановка (expansion). То есть то, что вы вводите, замешается чем-то другим.

Рассмотрим, как работает команда `echo`, которая выводит свои аргументы в стандартный поток вывода:
```bash
$ echo *
>>> file.txt file2.txt dir1 dir2 Dir3
$ echo f*
>>> file.txt file2.txt
$ echo [[:upper:]]*
>>>Dir3
```
Оболочка сделала замену символа `*` и поэтому вывелся не он, а готовый результат подстановки.

Мы также можем **заклянуть за пределы каталогов*:
```bash
echo /usr/*/share
>>>/usr/kerberos/share /usr/local/share
```

==Подстановка путей== (pathname expansion) - механизм работы групповых символов.

#### Подстановка пути для скрытых фалйов
Мы можем использовать команду `$ echo .*`, но она может привести к неправильным результатам, так как эти имена соответствуют текущему рабочему каталогу и родительскому каталогу (. и ..). Проверить это моожено введя `$ ls -d .\* | less`. **Для решения проблемы мы используем специальный шаблон**, который замещается именами файлов, начинающимися с точки, за которой следует хотя бы один символ, кроме точки, за которым в свою очередь может следовать любое кол-во символов:
```bash
$ ls -d .[!.]?*
```

#### Подстановка результатов арифметических выражений
Командная оболочка поддерживает подстановку арифметических выражений. Для нее используестя слудующий формат: `$((Выражение))`. Выражения могут содержать вложенные выражения Этот механизм поддерживает только **целые числа**.
```bash
$ echo $((2+2))
>>>4
$ echo $(($(5**2))*3) #echo $(((5**2)*3))
>>>75
```

**Арифметические операторы:** `+`, `-`, `*`, `/` (деление на цело, результат - целове число), `%` (остаток от деления), `**` (возведение в степень)

#### Подстановка фигурных скобок
С помощью фигурных скогок можно создать множество текстовых строк:
```bash
$ echo VV-{A,B,C}-MM
>>>VV-A-MM VV-B-MM VV-C-MM

#использование диапазона чисел и букв
$ echo ch_{1..3}
>>> ch_1 ch_2 ch_3
$ echo {Z..A}
<<<<<<< HEAD
>>>Z Y X W V U T S R Q P O N M L K J I H G F E D C B 

#создание 30 папок:
$ mkdir dir_{1..30}
```

#### Подстановка параметров
\- это переменные, коорые храянят некоторые данные
```bash
#вывести список доступных переменных:
$ printenv | less

$ echo $USER #хранит ваше имя пользователя
>>>denis
```

Если ошибиться в имени параметра, результатом подстановки будет **пустая строка**.

### Подстановка команд
Подстановка команд позволяет использовать поток вывода команд в качестве аргументов других команд:
```bash
$ echo $(ls)
>>>Desktop Documents ls-output.txt Music Pictures Public Videos

$ ls -l $(which cp) 
>>>-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp

$ file $(ls /usr/bin/* | grep zip)
>>>/usr/bin/bunzip2: symbolic link to \`bzip2'
>>>/usr/bin/gzip: symbolic link to \`../../bin/gzip'
>>>...

$ echo {A..Z}
>>>Z Y X W V U T S R Q P O N M L K J I H G F E D C B A

#вложенные фигурные скобки:
$ echo a{A{1,2},B{3,4}}b
>>>aA1b aA2b aB3b aB4b
```

#### Подстановка команд
\- Позволяет использовать поток вывода команд в каче тсе аргументов других команд:
```bash
$ echo $(ls)
>>>Desktop Documents ls-output.txt Music Pictures Public Templates 
$ ls -l $(which cp)
>>>-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp

$ file $(ls /usr/bin/* | grep zip)
>>>/usr/bin/bunzip2: symbolic link to `bzip2'
>>>/usr/bin/gunzip: symbolic link to `../../bin/gunzip'
```
Механизм подстановки команд имеет альтернативный синтаксис, унаследованный от более старых командных оболочек, который также поддерживается в bash . В нем вместо знака доллара и круглых скобок используются обратные апострофы(\`\`):
```bash
$ ls -l `which cp`
>>>-rwxr-xr-x 1 root root 71516 2012-12-05 08:58 /bin/cp
```

## Экранирование (quoting)
Механизм разбиения на слова в командной оболочке удаяляет дополнительные пробелы из списка аргументов команд, а также в некоторых случаях подставляет пустую строку:
```bash
$ echo this is a    test
>>>this is a test

$ echo Итого $100.00
>>>Итого 00.00
```

#### Двойные кавычки
\- При заключение в двойные кавычки вы можете создавать директории и файлы из нескольких слов с пробелами. Специальные символы теряют свое значение, кроме `$`, `\`  и \` *(подстановка путей, тильды и фигурных скопок выполнятьтся не будет, но подстановка параметров, значений арифметики и команд будут выполняться)*. Запомните: **подстановка параметров, команд и арифметики выполняется в двойных кавычках** (иначе вывод может быть не совсем правильным):
```bash
$ echo $(cal)
>>> January 2021 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

$ echo "$(cal)"
>>>    January 2021      
Su Mo Tu We Th Fr Sa  
                1  2  
 3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30  
31     
```
В первом случае подстановка команд без кавычек привела к созданию командной строки с 38 аргументами, а во втором случае получилась командная строка с одним аргументом, включающим внутренние пробелы и символы перевода строки.

Дело в том, что если добавить двойные кавычки, разбиение на слова выполняться не будет и внутренние пробелы не будут считаться **разделителями** — они станут частью
аргумента.

#### Одиночные кавычки
Одиночные кавычки **подавляют все подстановки**:
```bash
$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
>>>text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER

$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
>>>text ~/*.txt {a,b} foo 4 danis

$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
>>>text /home/danis/*.txt a b foo 4 danis
```


#### Экранирование символов
Если необходимо экранировать только один символ, надо добавить перед ним обратный слеш (называестя экранирующим символом, escape character):
```bash
$ echo "Баланс счета пользователя $USER: \$5.00"
>>>Баланс счета пользователя me: $5.00
```

Экранирование символов также работает при создании имен файлов, когда надо экранировать пробел, `$`, `~`, `&`.
```bash
$ mkdir dir\ txt 
#будет создана дирректория 'dir txt'
```

##### Управляющие последовательности
Обратный слеш может быть использован также как часть специальных символов, которые называют управляющими кодами (первые 32 символа ASCII). Речь о таких командах, как \\t (табуляция), \\n (переход на новую строчку), \\r (возврат коретки), \\b (backspace)

Для использование этих символов в команде `echo` необходимо добавить параметр `-e`, либо использовать конструкцию `$'управляющая последовательность'`:
```bash
$ echo -e "Time's up\a"
>>> Time's up

$ echo "Time's up" $'\a'
>>> Time's up
``
>>>>>>> 72a0272b92320892ef761cd37a721504d500d02e
```

## Механизм подстановки параметров
```bash
foo="This is some"
echo $foo
>>>This is some
foo=$foo" text."
echo $foo
>>>This is some text.
```

Используя этот прием, можно добавлять текст в конец содержимого переменной.