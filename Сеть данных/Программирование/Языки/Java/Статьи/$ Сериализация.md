# Способы сохранения данных, объектов и их восстановление. 
теги: #java 

---
### Общие вопросы: 

- Какие бывают способы сохранения состояния объектов?  
- Чем эти способы отличаются (преимущества и недостатки)? 
- Как записать текст в файл? 
- Чем отличаются цепные и соединительные потоки и в чем их предназначение? 
- Как извлечь текст из файла? 
- Что нужно, чтобы сериализировать объект? 
- Как извлечь сериализированные данный? 
- Ответьте на вопросы class [[class File]]. 
- В чем опасность использования десериализации? 
- Как контролировать версии класса, чтобы избежать ошибок при десериализации? 
- Назовите изменения класса, которые допустимы и не допустимы. 
- Ответьте на вопросы [[class InputStream (abstract)]] & [[class OutputStream (abstract)]] 
- Как преобразовать строку в массив байтов и записать в файл? 

 ![[Pasted image 20201205214453.png]]

### Ответы на вопросы: 
Есть два способа сохранения состояния объектов: 

- Есть два способа сохранения данных:
	- Записать сериализованные объекты в файл. 
	- Создать простой текстовый файл и использовать метод `split(String s)` для чтения. 
 
- ==Потоки для соединений== представляют собой подключения к пунктам назначения и источникам, например файлам или сетевым сокетам. Этот API соединяет потоки, работающие в связке только с другими потоками. Чтобы сделать что-нибудь, нужно вызвать два потока - для соединения и для вызова методов. *Потоки для соединений* обычно низкоуровневые. *Цепной поток* же высокоуровневый. [[$ class FileOutputStream]] записывает байты в файл; [[$ class ObjectOutputStream]] преобразует объекты в данные, которые могут быть записаны в поток. 


- Чтобы *сериализировать объект*, он и его поля-объекты должны реализовывать интерфейс [[interface Serializable]] (также они могут быть помечены словом transient, тогда объект не будет сериализироваться). Далее пишем следующее: 

	```java
	ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("MyFile.ser")); 
	//Чтобы сериализировать объект в файл "MyFile.ser", нам потребуется использовать //метод   
	os.writeObject(Object obj); 
	//Не забываем закрыть поток: 
	os.close(); 
	```
 

- *Десириализация и восстановление объекта*. Применим конструкцию try-with-resources, которая объявляет ресурс и закрывает его по окончанию кода в теле try: 

	```java
	try (ObjectInputStream os = new ObjectInputStream(new FileInputStream("MyFile.ser"))) { 

	Cat cat = (Cat) os.readObject(); //читаем объекты 

	} catch (IOException e) {} 
	```

	Объекты считываются в том же порядке, в котором они были записаны. 

 
- Запись строки в текстовый файл. Вы должны занать о классах [[class File]], [[$ class BufferedWriter]] и [[$ class BufferedReader]]. 
	```java
	try { 
	BufferedWriter writer = new BufferedWriter(new FileWriter(new File("File.txt"))); 
	writer.write("Привет, мир"); 
	writer close(); 
	} catch(IOException e) {} 
	```
	Мы могли бы обойтись без [[$ class BufferedWriter]], но с ним программа эффективнеее, а с File программа безопаснее. 

- Чтение из текстового файла: 
	```java
	try (BufferedReader reader = new BufferedReader(new FileReader(new 			 							    File("File.txt")))){ 
		   String line = null; 
		   while ((line=reader.readLine()) != null){ 
			   System.out.println(line); 
		   } 
		} 
	catch(IOExceptione){ e.printStackTrace(); } 
	```

	Если нужно подсчтитать все строки из файла, достаточно написать следующее: 
	```	java
	public static List<String> allLines = new ArrayList<String>(); 
	allLines = Files.readAllLines(Paths.get(bufferedReader.readLine())); 
	//если не работает: 
	//allLines = Files.readAllLines(Paths.get(r.readLine()), Charset.forName("windows-1251")); 
	```

 
***Проблемы десериализации.*** Если вы сериализируете объект, то должны иметь класс для его десериализации и дальнейшего использования. Если за это время класс будет изменен, то при десериализации могут возникнуть ошибки совместимости. 
 
`Допустимые изменения:`
- Добавление новых переменных в класс. 
- Добавление классов к иерархии наследования. 
- Удаления классов из иерархии наследования. 
- Изменения уровня доступа переменной не влияет на способность десериализации присваивать ей значение. 
- Замена непереходной переменной на переходную. 
 
`Недопустимые изменения:`
- Удаление переменной экземпляра. 
- Изменения объявленного типа переменной.  
- Замена непереходной переменной на переходную. 
- Перемещение класса вверх или вниз по иерархии наследования. 
- Изменения класса из Serializable в не-Serializable. 
- Превращение обычной переменной в статическую. 



>Чтобы десериализировать измененный класс, необходимо использовать ***serialVersionULD***. 

Каждый раз, когда объект сериализуется, он вместе со всеми объектами в графе "маркируется" идентификациионным номером версии своего класса (ID по названия serialVersionUID). Если класс был изменен после сериализации, то при десериализации объекта он может иметь уже другой serialVersionUID и операция провалится. Но вы можете контролировать этот процесс.  

Если есть хоть какая-то возможность, что ваш класс мог поменяться, добавьте в него серийный идентификационным номер версии. После помещения serialVersionUID в класс этот ID не будет меняться. Вам необходимо узнать serialVersionUID вашего класса (например с помощью `serialver` в командной строке) и вставить его в класс: 
```java
 static final long serialVerisonUID = -6849794470754667710L; 
```
 

**Пример преобразования строки в массив байтов и запись в файл: **
```java
FileOutputStream outputStream = new FileOutputStream("D:/Users/Username/someFile.txt"); 
BufferedOutputStream bufferedStream = new BufferedOutputStream(outputStream); 
String text = "I love Java!"; 
byte[] buffer = text.getBytes(); 
bufferedStream.write(buffer, 0, buffer.length); 
bufferedStream.close(); 
```
 