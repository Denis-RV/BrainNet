# Процессы
*Need to know:* [[1.7 Привилегии]]
*status:* Готово
*format:* flow
*tegs:* #linux #programming 
*description*: Иногда компьютер становится "вялым", или приложение перестает откликаться на команды. Статья ознакомит вас с инструментами командной строки, поволящеими увидеть, что делают программы, и завершит процессы, вышедшие из-под контроля.

---
Команды:
```bash
$ ps aux #делает список процессов с их потреблением
$ top #выводит процессы в динамике
$ jobs #выводит список активных заданий
$ bg #переводит задание в фоновый режим работы
$ fg #переводит задание на передний план

$ kill #убивает процесс
$ killall #останавливает процессы по именам

$ pstree #выводит список процессов в виде древовдиной
#структуры, отражающей отношения "родитель-потомок"
#между процессами.
$ vmstat #выводит мгновенный снимок с ифомрацией 
#об использовании системных ресурсов. Чтобы увдиеть, 
#как изменяется инфомрация с течением времени, 
#передайте интервал задержки (в секундах), например vmstat 5.
$ xload #программа с графическим интерфейсом, 
#показывающая изменение нагрузки на систему с течением времени
$tload #похожа на xload, но рисует график в терминале.

$ shutdown #оостанавливает или перезагружает систему
$ reboot #перезагрузка системы
```

В момент запуска система запускает программу с названием ***init***, которая выполняет последовательность сценариев командной оболочки (находятся в /etc), называемые *сценариями начальной загрузки (init scripts)*, которые запускают все системыне службы. Некторые службы реализованы как *программы-демоны (daemon programs)* - программы, действующие в фоновом режиме и выполняющую работу без участия пользователя.

Принцип, по которому программа может запускать другие програмы, выражается правилом: *родительский процесс запускает дочерний процесс*.

Каждый процессор имеет свой *идентфикатор процесса (Process ID, PID)*, а процесс init получает идентификатор 1.

### Просмотр списка процессов с помощью ps
**Чтобы получить подробный вывод о всех процессах и об используемых ими ресурсах, введите `ps aux`**.

Без аргументов и параметров команда выводит только процессы, связанные с текущим сеансом. 
- TTY - teletype, содержит информацию об управляющем терминале процесса. В Unix в этом поле выводиться тип терминала.
- TIME - объем процессорного времени, потребляемого процессом.
- VSZ - виртуальная память
- RSS - размер страниц памяти. Объем ОЗУ, используемой процессом, кб
- START - время запуска процесса
- STAT - state (состояние), столбец содержит информацию о текущем состоянии процесса:![[Pasted image 20210115195521.png]]

Если добавить параметр `x`, выведуться все процессы, происходящие в системе.

### Команда top
\- Поволяет увидеть работу компьютера каждые 3 с. Вывод команды top делится на две части: сводная информация о системе и таблица процессов, отсортированных по потреблению ими процессора.
- Описание вывода top:![[Pasted image 20210116221347.png]]

## Управление процессами
Для практики можно воспользоваться программой xlobo (или gedit/kwrite), введя ее название в консоли. Попробуйте изменить размер окна.

Команды прерываюстя с помощью `Ctrl+C`

#### Перевод процессов в фоновый режим
Если вам нужно вернуться в командную оболочку, не прирывая выполнения программы, вы можете перевести ее в фоновый режим. Чтобы сразу запустить программу в фоновом режиме, нужно добавить в конец команды символ фмперсанда (&):
```bash
$ xlogo &
>>> [1] 28236
#28236 - PID процесса
#[1] - задание процесса

$ ps
>>>PID TTY TIME CMD
   10603 pts/1 00:00:00 bash
   28236 pts/1 00:00:00 xlogo
   28239 pts/1 00:00:00 ps
   
$ jobs
>>>[1]+ Running		xlogo &
```

***Для перевода команды из фона на передний план необходимо использовать fg:
>fg %number_process
```bash
$ fg %1 #если задание одно, можно без номера
xlogo
```

#### Приостановка процесса
Когда нам требуется приостановить процесс переднего плана на время, не завершая его, используйсте комбинацию `Ctrl+Z` Попробуйте приостановить xlogo и изменить размер окна. Чтобы ее венуть, введите `$ bg %1`.

---

### Посылка сигналов процессам

Убить процесс можно с помощью команды `kill (PID/%number_process)`. Сначала программа запускается в фоновом режиме, выводиться номер задания и идентификатора, далеевызывается `kill`. На самом деле `kill` посылает программам сигнал, чтобы она завершилась. Это позволяет программам сохранить промежуточные результаты при получении сигнала.

На самом деле kill может посылать разные сигналы:
>kill [-(number_/name_signal)] PID...

Программа может сама решать, как реагировать на сигнал, за исключением сигнала `KILL` и `STOP`.

Сигналы, которые может послать kill:
- `15` - `-TERM`, сигнал по умолчанию (terminate-завершить).
- `2` - `-INT`, прервать. Та же функция, что у клавиши `Ctrl+C`.
- `9` - `-KIL`L, уничтожить. Этот сигнал передается не целевой программе, а ядру, и ядро немедленно завершает указанный процесс. Процесс не имеет возможности "прибрать за собой" или сохранить результаты работы.
- `19` - `-STOP`, приостановить. Сигнал заставляет процесс остановитсья, не завершаясь. Он также передается в ядро,а не целевому процессу, и поэтому не может быть проигнорирован им.
- `18` - `-CONT`, продолжить. Сигнал восстанавливает нормальную работу процесса после сигнала `STOP`
- `1` - `-HUP`, обрыв связи. Этот сигнал также используется многими демонами для 
повторной инициализации. Демон перезапускается и повторно читает свои конфигурационные файлы. 

**Полный список сигналов можно получить, выполнив команду `kill -l`.**

Примеры:
```bash
$ xlogo & 
>>>[1] 1001
$ kill -INT 1
>>>[1] Interrupt xlogo

$ xlogo & 
$kill -1 1001
>>>[1]+ Hungup xlogo
```

==Чтобы послать сигнал процессу командой kill, вы должны быть владельцем процесса или суперпользователем.==

#### Посылка сигналов нескольким процессам с помощью `killall`.
Эта команда посылает сигнал процессам, соответствующим указанной программе или имени пользователя.
>killall [-u user] [-signal] programm_name...

```bash
$ xlogo &
>>>[1] 1001
$ xlogo &
>>>[2] 1002
$ killall xlogo
>>>[1]- Terminated xlogo
>>>[2]+ Terminated xlogo
```