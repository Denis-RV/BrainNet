# Перенаправление ввода/вывода
*Need to know:* [[1.3 Работа с командами]]
*status:* Ready
*format:* flow
*tegs:* #linux #programming #editText 

---
Команды:
```bash
$ cat #объединяет файлы
$ sort #сортирует строки текста
$ uniq #сообщает о повторяющихся строках или удаляет их
$ wc #выводит число строк, слов и байтов в указанном файле
$ grep #находит и выводит строки, соответсвующие шаблону
$ head #выводит первые строки из файл
$ tail #выводит последние строки из файла
$ tee #читает данные со стандартного ввода и записывает в 
#стандартный вывод и в файлы
```

#### Перенаправления стандартного вывода (ошибок)
Вывод делиться на два типа: 1)результаты работы программы, 2)сообщения о состоянии или об ошибках. Команды выводят свои результаты в специальные файлы (standard output, stdout - 1 тип, standard error, stderr - второй тип), но по умолчанию многие выводы команд связаны с экраном и не сохранаяются на диске. Также многие программы принимают ввод из специального файла standard input, stdin, который по умолчанию связан с клавиатурой.

==Чтобы перенаправить стандартный вывод в другой файл вместо экрана, нужно добавить в команду оператор перенаправления > и имя файла.ВАЖНО: при перенаправлении вывода с помощью оператора > файл назначения всегда перезаписывается с самого начала. Чтобы не перезаписывать файл, а добавить информацию в конец, необходимо использовать >>==

Пример перенаправления вывода:
```bash
$ ls -l /usr/bin > ls-output.txt

$ > ls-out.txt #создаст новый файл или очисстит старый
$ ls -l /usr/bin >> ls-output.txt #добавит вывод в конец файла

```

Чтобы перенаправить стандартный вывод ошибок, нужно указать его дескрпитор файла (0-ввод, 1-вывод, 2-вывод ошибок):
```bash
$ ls -l /bin/usr 2> ls-error.txt
```

Перенаправление стандартного вывода и стандартного
вывода ошибок в один файл осуществляется 2 способами:
```bash
#First way. Необходимо сначала перенаправлять стандартный вывод.
$ ls -l /bin/usr > ls-output.txt 2>&1

#Second way. 
$ ls -l /bin/usr &> ls-output.txt # перезапись файла
$ ls -l /bin/usr &>> ls-output.txt # вывод в конец файла
```

##### /dev/null
- этот файл представляет системное устройтсво под названием битоприемник (bit bucket), или мусорная корзина, которая принимает любой ввод и ничего с ним не делает. Перенаправляйте сюда файлы, чтобы подавить вывод сообщений об ошибках.

#### Перенаправление стандартного ввода
Команда cat читает содержимое одного или нескольких файлов и копирует его в стандартный вывод (без возможности пространичного просмотра).

С помощью команды `cat` можно обхединять файлы:
```bash
# имеем файлы movie.mpeg.001, movie.mpeg.002 ... movie.mpeg.099
$ cat movie.mpeg.0* > movie.mpeg
```

Если ввести `cat` без аргументов, она будет выводить ввод в стандартный вывод. Это можно использовать для создания коротких текстовых файлов.
```bash
$ cat > record.txt
Any text
More text
Ctld + D
$ 
```
#### Конвейеры (оператор канала)
Оператор конвейера `|` (вертикальная черта) - вывод одной команды можно связать с вводом другой: `command1 | command2`.
Например:
```bash
$ ls -l /usr/bin | less
```
С помощью этой команды можно ислодовать вывод любой команды, посылающей результаты на стандартный вывод.

#### Фильтры
Конвейеры позволяют объединить вместе несколько команд, и такие приемы называют ==фильтрами==. Фильтры принимают ввод, изменяют его определенным образом и выводят результат.

Например нам нужно составить список всех выполняемых программ в каталогах /bin и /usr/bin, расположив их по алфавиту. Это делается через `sort`:
```bash
$ ls /bin /usr/bin | sort | less
```

- Команда `uniq` принимает сортированный список данных либо со стандартного ввода, либо из файла, имя которого можно передать в единственном аргументе, и по умолчанию удаляет повторяющиеся строки из списка.
	```bash
	$ ls /bin /usr/bin | sort | uniq | less #удаление дубликатов

	$ ls /bin /usr/bin | sort | uniq -d | less #вывод дубликатов
	```

- Команда `wc` считает количество строк, слов и байтов в файлах:
	```bash
	$ wc ls-output.txt
	>>>7902 64566 503634 ls-output.txt
	```


- Команда `grep` находит совпадение с шаблоном в файле и выводит строку с найденным сопвадением. Пармаметр `-i` требует от grep игнорировать регистр, параметр `-v` требует от grep выводить только строки, где совпадений было не найдено. Чтобы использовать сложные шаблоны, необходимо владеть регулярными выражениями ([[$ Syntax Regex]]).
	( #task: Добавить ссылку на стартью про регулярные выржанеия.)
	```bash
	#grep template [file]
	#Попробуем найти все, что содержит слово zip:
	$ ls /bin /usr/bin | sort | uniq | grep zip
	>>>bunzip2
	>>>gunzip
	>>>gzip
	>>>...
	```

- Команды `head/tail` - вывод первых/последних строк из файлов. По умолчанию обе команды выводият 10 строк, но это чистло можно изменить с помощью парамтре `-n`:
	```bash
	$ head -n 5 ls-output.txt
	$ tail -n 5 ls-output.txt

	$ ls /usr/bin | tail
	```

	Команда `tail` с аргументом `-f` позволяет также следить за изменениями в файле.

- Комманда tee читает со стандартного ввода и записывает в стандартный вывод и в файлы, чтобы дать возможность передать их дальше по конвейеру. Это может пригодиться для сохранения промежуточных результатов обработки в конвейере. Например сохраним полный список файлов в каталогах в файле ls.txt, перед тем, как он будет отфильтрован командой `grep`:
	```bash
	$ ls /usr/bin | tee ls.txt | grep zip
	```
