# Java Base
*status:* In process
*format:* root stage
*tegs:* #programming #java 
*desckritpion:* Основые конструкции, методы, ключевые слова, тонкости и основные возможности Java.

---
# Конструкции в Java:
### Исключения try-catch-finally
Синтаксис:
```java
try {
	//code, whitch throw exception
} catch (NullPointerException  e) {
	//what will happend, if exception cathced
} catch (Exception e) {
	//what wiil happend, if exception cathced
} finally {
	//wath will happend anyway
}
```
Блок finally писать не обязательно



# Понятия в Java
### Перегрузка методов
- Если неизвестно, сколько параметоров может принимать метод, мы можем использовать ==аргументы переменной длины==:
	```java
	publcic int sum(int... numbers)
	
	//Это аналог следующей конструкции:
	public int sum(int[] numbers)
	```

### Отшношения в ООП
#### Ассоциация
\- когда один объект использует другой, либо зависит от него. Двустороння ассоциация между объектами вполне допустима. 

#### Композиция
\- это отношение «часть-целое» между двумя объектами, когда один из них включает в себя другой. Особенность этого отношения заключается в том, что компонент может существовать только как часть контейнера. 

#### Агрегация 
\- это менее строгий вариант композиции, когда один объект просто имеет ссылку на другой объект. Здесь контейнер не управляет жизненным циклом компонента. Компонент может существовать отдельно от контейнера. 

### Анонимные классы
\- классы без переменных и имени. Их удобно использовать, когда нужно воспользоваться объектом лишь раз, при этом можно сразу прописать локигу.

Попробуем использовать интерфейс как ананоимный класс:
```java
Directror director = new Director();
director.force(new Cookable() {
	@Ovveride
	public void cook() {
		System.out.prinln("Cookink");
	}
});
```

### Модификаторы доступа
- public - 
- private - 
- protected - 
- default (package) - 

### Generic
\- Обобщенный тип или параметриизированный класс. При создании экземпляра класса можно указать тип объектов, которые будут использованы в классе. Для этого нужно рядом с названием класса поставить угловые скобки и указать в них букву `T` (можно любую букву, но принято T).

```java
public class Box<T> {
	private T object;
}
```

Generic'и позволят нам следующее:
- Избавлятся от необходимости явного приведения типов:
	```java
	int sum = (int) box.getObject()
	```
- Компилятор не позволит нам присвоить то, что ему присваивать нельзя, например присвоить объекту типа \<Integer\> строку. То есть нам не нужно это проверять через instanceof.

В случае, если мы не указываем тип параметра в `<>`, то вместо `T` автоматически подставиться класс `Object`.

**Мы также можем указать множество параметров: `<T, K, V>`**

#### Продвинутые параметры 
Мы можем использовать тип классов, которые будут наследоваться от другого клаасса:
`<T extends Number>`

Также мы можем использовать только те типы, которые реализуют указанные интерфейсы. Это делается с помощью знака `&`:
`<T extends Number & Comparable<T> & Serializable>`

***Это позволяет нам использовать методы интерфесов!***

##### WildCard (Маска)
\- параметр `?`, обозначающий, что тип параметра может быть любым.
Если мы хотим сравнивать между собой объекты разных типов, мы можем воспользоваться следующей конструкцией:
`compare(Box<?> another)`
Также мы можем наложить некоторые агроничения:
`compare(Box<? extends Number> another)`

**Разница между List\<Number\> и List/<\? extends Number\>** заключается в том, что в первом случае мы не можем использовать list\<Integer\>, т.к. коллекция типа Integer не наследуется от коллекции типа Number.
#### Параметризированные методы
Чтобы создать такой метод, который мог бы возвращать параметризированный объект, нам надо не только написать любую букву перед названием метода, но и заключить эту же букву отдельно в триугольные скобочки:
```java
public static <U> U getElement(List<U> list) {...}
```

Приставка \<U\> означает, что метод параметризирован. Это также надо использовать для аргументов:
```java
public static <T> void transfer(List<T> src, List<T> dst) {...}
```

***Коллекция источник может быть либо типом T, либо ее наследником, но коллекция назначения может быть либо типом T, либо его родителем.
```java
public static <T> void transfer(List<? extends T> src, List<? super T> dst) {}
```
# Ключевые слова
###  static
- Статичные методы - их можно вызывать без создания экземляра класса. В этих методах нельзя напрямую вызывать нестатичные методы и обращаться к нестатичным переменным.

### final
- Этим словом помечаются **переменные**, если необходимо, чтобы они были неизменяемыми (константами). Такие констанктные переменные принято писать заглавными буквами.

### instanceof
- Этот оператор позволяет определить, к какому классу принадлежит объект:
```java
if (obj instanceof Cat) { ... } else ...
```



#  Важные методы в java:
- Math.random() - генератор рандомных чисел. Подробнее [[class Math]]

# Terms Java
==Атомарная операция== - это операция, которая завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным. Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени. Неатомарные операции не дают такой гарантии. 

==Нативный==  - тот, который является платформенно-зависимым. 

==Квант== - небольшой кусочек процессорного времени, которвый выделяется каждой нити. Когда это время истекает – процессор переключается на другую нить и начинает выполнять ее команды. 

==Сокет== (класс java.net.Socket) - это объект, представляющий сетевое соединение между двумя компьютерами, а именно между двумя узлами, программное обеспечение которых знает о существовании друг друга. Чтобы создать сокет, нужно знать о сервери две вещи: где он находится и а каком порту работает (IP-адрес и номер порта). 

==Стирание типа== - информация о типе-параметре доступна только на этапе компиляции и становится недоступной во время выполнения (наприамер generic).