

class **BufferedWriter, BufferedReader,** 

**BufferedInputStream, BufferedOutputStream**.

- Делает работу с потоками гораздо эффективнее.
- Классы-обертки (BIS и BOS для InputStream и Outputstream, а BW и BR для Writer и Reader).
- BufferedInputStream принимает на вход InputStream и его наследников. В качестве дополнительного параметра он принимает размер буфера в байтах. Теперь благодаря этому данные будут считываться из файла не по одному байту, а по 200! Представь, насколько мы сократили количество обращений к файлу.

interface **InputStream** & **OutputStream** 

— это абстрактные классы, которые отвечает за байтовый ввод и вывод

Вопросы:

- Как копировать данные из одного файла в другой? (по 1 байту и блоками байтов)

Методы класса InputStream:

- **int available()** - возвращает число байт, доступных для чтения;
- **close()** - закрывает источник ввода.
- **int read()** - возвращает целочисленное представление следующего доступного байта в потоке (символ). Если достигнут конец потока, будет возвращено число -1.
- **int read(byte[] buffer)** - пытается читать байты в буфер, возвращая количество прочитанных байтов(а не их значение). Когда он достигает конца файла, возвращает значение -1.
- **int read(byte[] buffer, int byteOffset, int byteCount)** - считывает часть блока байт. Используется, когда есть вероятность, что блок данных был заполнен не целиком. Когда он достигает конца файла, возвращает -1.
- void flush() - очищает все буферы вывода.
- **long skip(long byteCount)** - пропускает byteCount, байт ввода, возвращая количество проигнорированных байтов.
- **void close()** - метод «закрывает» поток, вызывается после окончания работы с потоком.

Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.

Из потока больше нельзя читать данные.

Методы класса OutputStream:

- **void write(int data)** - метод записывает очередной байт, обрезая переменную data до одного байта.
- **void white(byte[] buff)** - метод записывает блок байт и возвращает количество прочитанных байтов (а не их значение).
- void write(byte[] buff, int from, int count) - записывает часть блока байт.
- **void flush()** - часто данные для записи сначала собираются в большие блоки в памяти, а потом только пишутся на диск. Команда flush требует немедленно записать всю несохраненную информацию на диск.
- **void close()** - метод «закрывает» поток, вызывается после окончания работы с потоком.

Ответы на вопросы:

**Побайтовое копирование данных из одного файла в другой:** 

public static void main(String[] args) throws IOException {

InputStream inStream = new FileInputStream("c:/source.txt");

OutputStream outStream = new FileOutputStream("c:/result.txt");

while (inStream.available() > 0) {

int data = inStream.read();

outStream.write(data); }

inStream.close();

outStream.close();

}

**Копирование данных блоками:** 

public static void main(String[] args) throws Exception {

FileInputStream inputStream = new FileInputStream("c:/data.txt");

FileOutputStream outputStream = new FileOutputStream("c:/result.txt");

byte[] buffer = new byte[1000];

while (inputStream.available() > 0) {

int count = inputStream.read(buffer);

outputStream.write(buffer, 0, count); //записать блок(часть блока) во второй поток

}

inputStream.close(); //закрываем оба потока. Они больше не нужны.

outputStream.close();

}

Когда мы читаем самый последний блок данных в файле, может оказаться, что байт осталось не 1000, а, скажем, 328. Тогда и при записи нужно указать, что записать не весь блок, а только его первые 328 байт.Метод read при чтении последнего блока вернет значение равное количеству реально прочитанных байт. Для всех чтений – 1000, а для последнего блока – 328.Поэтому при записи блока мы указываем, что нужно записать не все байты из буфера, а только 328 (т.е. значение, хранимое в переменной count).

abstract class **Reader** & **Writer** 

- Похожи на InputStream и OutputStream, но работают с символами. Применяются для работы с текстовой информацией.

Методы класса Reader:

- **int read(char[] cbuf)** читает много символов в буфер(массив символов), пока буфер не заполниться. Метод возвращает кол-во прочитанных символов (может быть меньше длины массива).
- **int read()** - читает 1 символ и возвращает его как результат, расширенный до int. Если доступных символво нет, метод вернет -1.
- **boolean ready()** - метод возвращает true если есть еще непрочитанные символы для методов read
- **void close()** - метод «закрывает» поток, вызывается после окончания работы с потоком.

Методы класса Reader:

- **int write(char[] cbuf)** метод записывает массив символов.
- **int write()** - метод записывает один символ. Тип int сужается до char, лишняя часть просто отбрасывается.
- **int write(String s)** - метод записывает строку. Она просто преобразовывается в массив символов и вызывается второй метод.
- **flush()** - если есть данные, которые хранятся где-то внутри и еще не записаны, то они записываются.
- **void close()** - метод «закрывает» поток, вызывается после окончания работы с потоком.

class **FileReader & FileWriter** 

class **FileInputStream & FileOutputStream** 

- позволяют последовательно читать из файла байты, а FileOutputStream – записывать в файл байты. Вот какие методы есть у этих классов. Чтобы обратиться к файлу на диске, необходимо указать имя этого файла в конструкторе.

Вопросы:

- Как записать строчку в файл с помощью метода write(byte[] buff)?
- Как добавить в файл информацию, не перезаписывая ее вместо старой.
- Как полчуить данные из файла?

Методы класса FileOutputStream:

- 

Ответы на вопросы:

**Чтобы записать строчку в файл, нужно вызвать у строчки метод getBytes():** 

new FileOutputStream(new File("MyFile")).write("Текст".getBytes());

**Чтобы добавить строчку в файл, нужно предеать в конструктор FileOutputStream дополнительный параметр - boolean append.** Если его значение true, данные будут дозаписаны в конец файла, иначе старые данные будут стерты, а новые записаны (по умолчанию всегда false):

new FileOutputStream(new File("MyFile"), true).write("Текст\n".getBytes());

**Получение данных из файла:** 

BufferedInputStream input = new BufferedInputStream(new FileInputStream(new File("File")), 200);

int i;

while((I = input.read())!= -1) { System.out.print((char)i); }

Обращение к источнику данных, например, чтение из файла, — дорогостоящая в плане производительности операция. И каждый раз обращаться к файлу для чтения по одному байту расточительно.

class **InputStreamReader & OutputStreamReader** 

- это потоки, которые принимают байты и конвертирует их в текстовые (символьные) данные. Как правило, они используется в качестве связующего звена между высокоуровневым BufferedReader или BufferedWriter и низкоуровневым входящим потоком из сокета.

class **PrintWriter** 

- нужет, чтобы записать текстовые данные на сервер. PrintWriter должен быть напрямую подключенн к исходящему потоку из сокета. Для отправки сообщений на сервер достаточно воспользоваться методами print() или println().

**Копирование данных из одного файла в другой:** 

FileReader reader = new FileReader("c:/data.txt");

FileWriter writer = new FileWriter("c:/result.txt");

while (reader.ready()) {

int data = reader.read();

writer.write(data);

}

reader.close();

Type equation here.

writer.close();

class **PrintStream** 

- выводит информацию в какой-то поток.

Вопросы:

- Как вывести информацию в файл?

Конструкторы класса:

- PrintStream(OutputStream outputStream)
- PrintStream(File outputFile)
- PrintStream(String outputFileName)

Методы класса Thread:

- **void print()**
- **void println()**

Ответы на вопросы:

**Вывод информации в файл:**  

PritnStream filePrint = new PrintStream(new File("С:\\User\\test.txt"));

filePrint.println("Helo world!");
