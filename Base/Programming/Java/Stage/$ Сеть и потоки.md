status: В процессе
format: stage
tegs: #programming #java 

### Общие вопросы: 

- Как заставить клиента работать? 
- Что такое "сокет"? 
- Что такое порт TCP? 
- Как считать данные из сокета? 
- Как записать данные в сокет? 
- Как создать серверное приложение? 

- Как создать новый исполняемый поток? 
- Как чередовать потоки? 
- В чем проблема параллелизма? Как ее избежать? 
- Как остановить поток? 
- Зачем нужно слово volatile? 

 

 

### Ответы на вопросы: 
- Чтобы заставить клиент работать, нужно научиться:
	- инициализировать соединение между клиентом и сервером;
	- отправлять сообщения на сервер; 
	- принимать сообщения от сервера; 

Соединение устанавливается с помощью сокета. 

 

- Сокет (класс java.net.Socket) - это объект, представляющий сетевое соединение между двумя компьютерами, а именно между двумя узлами, программное обеспечение которых знает о существовании друг друга. Чтобы создать сокет, нужно знать о сервери две вещи: где он находится и а каком порту работает (IP-адрес и номер порта). 

Создание сокета: 
```java
Socket socket = new Socket("196.164.1.103", 5000); 
```

 - Порт TCP - это 16-битное число, с помощью которого распознается конкретная программа на сервере. Номера портов с 0 по 1023 зарезервированы для популярных сервисов, их нельзя использовать. Выбирайте номер между 1024 и 65 535. 

- Чтение данных из сокета осуществляется также, как и чтение данных из файла, но вместо File мы используем Socket: 
```java
Socket chatSocket = new Socket("127.0.0.1", 5000); 
Buffered reader = new BufferedReader(new InputStreamReader(chatSocket); 
String message = reader.readLine(); 
```

 

- Запись данных в сокет осуществдяется с помощью класса PrintWriter: 
```java
Socket chatSocket = new Socket("127.0.0.1", 5000); 
PrintWriter writer = new PrintWriter(chatSocket.getOutputStream()); 
writer.println("Сообщение 1"); 
writer.pritn("Сообщение 2"); 
```

 

- Чтобы создать серверное пирложение, нам нужен ServerSocket, который ожидает запросов со стороны клиента (когда клиент выполняет new Socket()), и обычный Socket для общения с клиентом. 
```java
//сервер начнет отслеживать входящие клиенткские запросы на порту 4242: 
ServerSocket serverSocket = new ServerSocket(4242); 
Socket sock = new Socket("190.165.1.103", 4242); 
//сервер создает новый сокет для общения с клиентом: 
Socket sock = serverSocket.accept();
```

Метод accept() блокирует программу, пока ожидает подключения клиентского сокета. 

- Создание исполняемого потока: 
```java
class RealRun implements Runnable { public void run() {} } 

Thread t = new Thread(RealRun); 

t.start(); 
```

Вместе с потоком должна быть задача, которую он выполняет, иначе поток умрет. Поток выполняется отдельно, то есть имеет свой стек вызовов. Главный поток на дне стека содержит метод main(). Чтобы создать задачу для потока, реализуйте интерфейс Runnable (который содержит метод public void run();), и передайте Runnable в конструктор Thread. 

 

- Чередование потоков можно контролировать с помощью метода Thread.sleep(long milliSec). Таким образов поток приостанавливается, и планировщик задач передает управление другому потоку. Этот метод может вызвать ислкючение InterruptedException. После приостановки поток станет работаспособным, но не сразу начнет выполнять свою работу (обычно это незаметно. 

 

- Использование потоков может сопровождаться проблемамой параллелизма. Проблема возникает, когда два или более потока имеют доступ к данным одного объекта. Чтобы быть уверенным, что, запустив метод наш поток будет иметь возможность завершить его, прежде чем другой поток сможет начать работу со счетом, нужно пометить этот метод словом synchronized. Это слово означает, что для работы с отмеченным кодом требуется ключ. Чтобы защитить свои данные, синхронизируйте методы, которые работают с этими данными. 

Важно! Если у объекта есть один или несколько синхронизированных методов, поток может выполнять их лишь при наличии ключа к объекту! Такие замки распространяются не на каждый метод отдельно, а на весь объект. 

 

- Остановить поток нельзя, но можно послать ему сигнал для остановки. Чтобы это сделать, нужно в методе run() написать следующее: 
```java
Thread current = Thread.currentThread(); 
while (!current.isInterrupted()) { 
//код для run() 
} 
```
И для остановки работы потока нужно написать thread.interrupt(); где thread - наш дочерний поток. 

 

- Словом volatile необходимо помечать переменные, с которыми имеют дело два и более потоков. Оно запрещает помещать заначение в кэш. Дело в том, что процессор может поместить значение переменной в кэш, и когда поток поменяет значение этой переменной, то для другово потока значение не поменяется (т.к. в медленной памяти значение не поменяется).  